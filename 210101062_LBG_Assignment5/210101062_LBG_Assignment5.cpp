// 210101062_LBG_Assignment5.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"       
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdlib>
using namespace std;

#define P 12
#define DELTA 0.0001	//delta value
#define EPSILON 0.03		//splitting parameter

vector<vector<long double>> universe;	//variables to hold the universe values and centroids
vector<vector<long double>> codebook;
vector<vector<int>> clusters;			//to keep track of the vectors in each cluster
vector<vector<long double>> prevCodebook;
string inputFile = "Universe.csv";    
int k = 1;		//codebook size
double tokhuraWeights[]={1.0, 3.0, 7.0, 13.0, 19.0, 22.0, 25.0, 33.0, 42.0, 50.0, 56.0, 61.0};			//tokhura's distance
int M = 0;

//function to print the code vectors
void printCodebook(){
	if(codebook.size() == 0){
		return;
    }
	cout<<"----------------------------------------------------------------------------------------------------------------------------------------------\n";
	for (int i=0; i<k; i++) {
        for (int j=0; j<P; j++) {
            printf("%10.7lf  ", codebook[i][j]);
        }
        cout << endl;
    }
}

//function to calculate the Tokhura distance between the current centroid and current row of universe
long double tokhuraDistance(vector<long double> &currentCentroid, vector<long double> &currentVector){
	long double ans = 0;
	for(int i=0; i<P; i++){
		long double d = currentCentroid[i]-currentVector[i];
		ans += (tokhuraWeights[i] * d * d);			//using tokhura distance
	}
	return ans;
}

//function to assign vectors of universe to a cluster using tokhura distance
void nearestNeighbors(){	
    for(int i=0; i<M; i++){
		int index = 0;
		vector<long double> currentVector = universe[i];   
		long double minDistance = LDBL_MAX;
		for(int j=0; j<k; j++){
			vector<long double> currentCentroid = codebook[j];
            long double distance = tokhuraDistance(currentCentroid, currentVector);		//distance between current cluster and current row of universe
            if(distance < minDistance){       
				minDistance = distance;
				index = j;
			}
		}
		clusters[index].push_back(i);		//add the index of the current vector to the cluster
	}
}

//function to calculate the average total distortion
long double totalDistortion(){
    long double totalDist = 0;
	for(int i=0; i<k; i++){
		int size = clusters[i].size();
		for(int j=0; j<size; j++){		//all the vectors of a particular cluster
			int index = clusters[i][j];
			totalDist += tokhuraDistance(codebook[i], universe[index]);
		}
	}
	long double avg = totalDist/M;		//taking average of total distortion
	return avg;
}

//function to update the cluster centroids
void updateCodeVector(){
	for(int i=0; i<k; i++){
		vector<long double> temp(P, 0.0);		//temporary vector to sum up all the universe vector values
		int size = clusters[i].size();
		for(int j=0; j<size; j++){
			int index = clusters[i][j];		//take index of the universe vector
			for(int k=0; k<P; k++){
				temp[k] += universe[index][k];		//add all the values of universe
			}
		}
		for(int j=0; j<P; j++){
			codebook[i][j] = temp[j]/((long double)size);		//take average for finding centroid
		}
	}
}

//Lloyds algorithm to perform vector quantization
void kMeans(){
	clusters.clear();
	clusters.resize(k);
	nearestNeighbors();
	long double dist = totalDistortion();
	long double distortion = 0;  //storing old distortion
	int m =1;
    printf("Distortion in iteration %2d: %.7lf\n", m, dist);
	while(abs(distortion - dist) > DELTA){		//until abs(current_dist - old_dist) becomes less than delta
		updateCodeVector();
		
		clusters.clear();		//clear the current clusters
		clusters.resize(k);
		nearestNeighbors();		//assign clusters for the next rounds

		distortion = dist;
		dist = totalDistortion();
		m++;
		printf("Distortion in iteration %2d: %.7lf\n", m, dist);
	}
}

//function to double the size of the codebook by splitting each current code vector
void splitCentroid(){
	for(int i=0; i<prevCodebook.size(); i++){
        vector<long double> t1, t2;
        for(int j=0; j<P; j++){			//calculating the new codebook entry
			long double v1 = ((1 + EPSILON) * prevCodebook[i][j]);
            t1.push_back(v1);
			long double v2 = ((1 - EPSILON) * prevCodebook[i][j]);
            t2.push_back(v2);
        }
        codebook.push_back(t1);
        codebook.push_back(t2);
    }
}

//function to implement Linde-Buzo-Gray algorithm
void LBGAlgo(){
    while(k <= 8){
        printf("\nCodebook size: %d\n", k);
        kMeans();
        printf("Codebook generated by LBG \n");
        printCodebook();
        if(k >= 8) return;
		prevCodebook = codebook;
        codebook.clear();
        splitCentroid();
		k *= 2;
    }
}

int main(){
	clusters.clear();
	clusters.resize(k); 

	fstream fin;
	fin.open(inputFile);    
	if(!fin){			//file does not exist
		fin.close();
		printf("Failed to open file\n");
		return 1;
	}
	long double word;
	char delim;
	while(fin >> word){			//until input is available
		vector<long double> line;
		line.push_back(word);
		for(int i=1; i<P; i++){
			fin>>delim>>word;
			line.push_back(word);	//save whole row
		}
		universe.push_back(line);	//add row to universe vector
	}
	fin.close();
	M = universe.size();

	if(M == 0) return 1;

    //Initialization - starting with centroid of whole universe
	vector<long double> initialCodeVec(P, 0.0);
    for(int i=0; i<M; i++){
        for(int j = 0; j<P; j++){
            initialCodeVec[j] += universe[i][j];
        }
    }
    for(int k = 0; k<P; k++){
        initialCodeVec[k] /= M;
    }
    codebook.push_back(initialCodeVec);

    LBGAlgo();
	return 0;
}

